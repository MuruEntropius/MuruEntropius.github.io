(window.webpackJsonp=window.webpackJsonp||[]).push([[5],{205:function(t,a,i){"use strict";i.r(a);var e=i(0),n=Object(e.a)({},(function(){var t=this,a=t.$createElement,i=t._self._c||a;return i("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[i("h1",{attrs:{id:"codeforces-1001-1099"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#codeforces-1001-1099"}},[t._v("#")]),t._v(" Codeforces(1001~1099)")]),t._v(" "),i("hr"),t._v(" "),i("h2",{attrs:{id:"_1155e"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#_1155e"}},[t._v("#")]),t._v(" 1155E")]),t._v(" "),i("ul",[i("li",[t._v("참조 코드: https://codeforces.com/blog/entry/66687")]),t._v(" "),i("li",[t._v("관련 지식:\n"),i("ul",[i("li",[t._v("Modular Multiplicative Inverse(모듈러 역수)")]),t._v(" "),i("li",[t._v("Gaussian Elimination(가우스 소거법)")]),t._v(" "),i("li",[t._v("Fermat's little Theorem(FiL, 페르마의 소정리)")])])])]),t._v(" "),i("h3",{attrs:{id:"modular-multiplicative-inverse"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#modular-multiplicative-inverse"}},[t._v("#")]),t._v(" Modular Multiplicative Inverse")]),t._v(" "),i("p",[t._v("Modular Multiplicative Inverse, 모듈러 역수란 정수 a에 곱해서 MOD P 연산을 하면 나머지가 1이 나오게 하는 수이다.\n예를 들어, m이  a * m === 1 (MOD P) 일때, m은 a mod P의 모듈러 역수이다. 모듈러 역수는 a와 p가 서로소 일때만 존재하며,\n항상 0과 p-1 사이의 값을 가진다.\na MOD P 의 모듈러 역수를 구하는 방법은 여러가지가 있다. m에 0부터 p-1의 값을 하나씩 넣어 보는 방법, 확장된 유클리드 호제법 등이 있다.   또는 p가 소수이고, a와 p가 서로소 일때 m === a^(p-2) (MOD p) 을 만족하므로 이를 계산 하는 방법이 있다.")]),t._v(" "),i("h3",{attrs:{id:"fermat-s-little-theorem-fil"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#fermat-s-little-theorem-fil"}},[t._v("#")]),t._v(" Fermat's little Theorem(FiL)")]),t._v(" "),i("p",[t._v('페르마의 소정리는 "소수 p와, p의 배수가 아닌 a가 있을때 항상 a^(p-1) === 1 (MOD p)를 만족함" 이다.')]),t._v(" "),i("h3",{attrs:{id:"gaussian-elimination"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#gaussian-elimination"}},[t._v("#")]),t._v(" Gaussian Elimination")]),t._v(" "),i("p",[t._v("가우스 소거법은 연립 일차 방정식을 푸는 해법중 하나이다.\n연립 일차 방정식 Ax = B이 있을때, A와 B를 붙여놓고\n* 행과 행을 바꾸기\n* 행에 0이 아닌 상수를 곱하기\n* 행에 상수를 곱하고 다른 행에 더하기\n등의 연산을 통해서 사다리꼴행렬로 만든 후, 아래서 부터 미지수를 구해나가는 Back Substitution을 통해 미지수를 구해나간다.")]),t._v(" "),i("hr"),t._v(" "),i("p",[t._v("위 링크의 Editorial의 코드를 해석하고 정리했다.")]),t._v(" "),i("p",[t._v('이 해답의 전략은 a_0부터 a_10를 연립일차방정식의 미지수로 두고, 가우스 소거법을 통해 해를 구하는 방법이다. 0부터 10까지의 "? i"쿼리에 대한 대답이 우변(위 코드에서는 mat[i][sz(f)]) 이 되는 것이다.')]),t._v(" "),i("div",{staticClass:"language- extra-class"},[i("pre",{pre:!0,attrs:{class:"language-text"}},[i("code",[t._v("    fore(j, 0, sz(mat)) {\n\t\tint nid = -1;\n\t\tfore(i, j, sz(mat)) {\n\t\t\tif(mat[i][j] != 0) {\n\t\t\t\tnid = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(nid == -1)\n\t\t\tcontinue;\n\t\t\n\t\tswap(mat[j], mat[nid]);\n\t\tfore(i, 0, sz(mat)) {\n\t\t\tif(i == j) continue;\n\t\t\tint cf = mul(mat[i][j], inv(mat[j][j]));\n\t\t\t\n\t\t\tfore(cj, j, sz(mat[i]))\n\t\t\t\tmat[i][cj] = norm(mat[i][cj] - mul(cf, mat[j][cj]));\n\t\t}\n\t}\n")])])]),i("p",[t._v("사다리꼴 행렬을 만들기 위해 0이 아닌 수를 mat[j][j]에 놓아야 한다. mat의 j번째 열을 밑으로 훑으면서 0이 아닌 수를 찾으면 mat[j]로 swap한다.")]),t._v(" "),i("p",[t._v('여기서부터가 정말 재미있어 진다. 저 반복문은 "행에 상수를 곱하고 다른 행에 더하기"작업을 실행하고 있다. 즉 cf는 multiplyer다. 보통의 multiplyer는 i/j겠지만, 모듈러 연산에서는 좀 다르다.')]),t._v(" "),i("p",[t._v("위 cf라는 수는 cj==j 일때, mat[i][cj]를 항상 0으로 만든다. 그 이유는 무엇일까?\ncf는 mat[i][j] * mat[j][j]^(p-2)이다.")]),t._v(" "),i("p",[t._v("따라서 cj=j(반복문의 시작)일때 mat[i][j] = norm(mat[i][j] - (mat[i][j] * mat[j][j]^(p-1)) MOD p)이다. 이때, 페르마의 소정리에 의해 mat[j][j]^(p-1)가 1이 되므로 남은건 norm(mat[i][j] - (mat[i][j] MOD p)), 즉 0이 된다.")]),t._v(" "),i("p",[t._v("연산을 계속하다 보면 이런식으로 된다.")]),t._v(" "),i("p",[t._v("반복문 fore(cj, j, sz(mat[i]))가 j에서 시작하는 이유는 보기처럼 j열 앞에 있던 수는 모두 0이 되었기 때문에 cf를 곱해 봤자 0이다. 그래서 필요가 없다.")]),t._v(" "),i("div",{staticClass:"language- extra-class"},[i("pre",[i("code",[t._v("vector<int> a(sz(f), 0);\nfore(i, 0, sz(a)) {\n\tif(mat[i][i] == 0)\n\t\tcontinue;\n\ta[i] = mul(mat[i][sz(a)], inv(mat[i][i]));\n}\n")])])]),i("p",[t._v("이제 a_0부터 a_10을 구했으니, 남은건 0부터 10^6+3까지 넣어보면서 조건을 만족하는 x를 찾으면 된다.")]),t._v(" "),i("hr")])}),[],!1,null,null,null);a.default=n.exports}}]);