(window.webpackJsonp=window.webpackJsonp||[]).push([[6],{209:function(a,t,r){"use strict";r.r(t);var v=r(0),_=Object(v.a)({},(function(){var a=this,t=a.$createElement,r=a._self._c||t;return r("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[r("h1",{attrs:{id:"codeforces-1300-1399"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#codeforces-1300-1399"}},[a._v("#")]),a._v(" Codeforces(1300~1399)")]),a._v(" "),r("hr"),a._v(" "),r("h1",{attrs:{id:"_1332"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_1332"}},[a._v("#")]),a._v(" 1332")]),a._v(" "),r("p",[a._v("20년 4월 9일 스터디에서 열심히 공부해 보았다.")]),a._v(" "),r("hr"),a._v(" "),r("h2",{attrs:{id:"a-b"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#a-b"}},[a._v("#")]),a._v(" A, B")]),a._v(" "),r("ul",[r("li",[a._v("A: x1==x2, 또는 y1==y2일때의 경우만 잘 처리해 주면 되는 문제(R1200)")]),a._v(" "),r("li",[a._v("B: 좀 부끄럽지만, 귀찮아서 증명없이 그냥 n을 1부터 시작하여 올려가면서 a_i 를 나누면 색칠하는 방법으로 했다. 왜 이런 생각을 했는지는 잘 기억이 안나네...(R1500)")])]),a._v(" "),r("h2",{attrs:{id:"c"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#c"}},[a._v("#")]),a._v(" C")]),a._v(" "),r("p",[a._v("길이 n, n의 약수 k, 길이 n의 문자열 s가 주어진다. s가 두가지 조건을 모두 만족하게 하는 최소 문자열 교체 회수는 몇인가를 묻는 문제다. 1. 회문(回文, palindrome)일 것, 2. s를 k등분 했을때 모두 같은 substring이 나올 것. (abcabcabc >> abc, abc, abc)")]),a._v(" "),r("p",[a._v("처음에는 test case 마다 그래프를 초기화 하고, 입력을 받아서 서로 같게 만들어야 하는 문자열의 인덱스를 그래프로 집어넣고, dfs를 통해 가장 많이 나온 문자열의 수를 답에서 빼주는 방식으로 했다. 접근 방법이 틀린 건 아닌데, vector"),r("int",[a._v(" graph[N]과 같이 선언된 것을 memset으로 해주니 TLE(시간 초과)가 떴다.")])],1),a._v(" "),r("p",[a._v("첫번째 substring 의 0번째와 n-1번째, 2번째 substring 의 0번째와 n-1번째, ... 을 탐색하여 가장 많이 나온 문자의 개수를 빼주고,\n첫번째 substring 의 1번째와 n-2번째, 2번째 substring 의 1번째와 n-2번째, ... 을 탐색하여 가장 많이 나온 문자의 개수를 빼주고...")]),a._v(" "),r("p",[a._v("위와 같은 방법으로 문자열을 조사하면 된다. 나름 재밌는 문제였음")]),a._v(" "),r("h2",{attrs:{id:"d"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#d"}},[a._v("#")]),a._v(" D")]),a._v(" "),r("p",[a._v("Bob이라는 친구가 and연산을 하는 경로 탐색에 dp를 사용했는데, 이는 항상 최적의 값을 보장하지 못한다. 우리는 bob을 놀리기 위해 bob의 알고리즘으로 계산 했을때 최적해보다 정확히 주어진 값 k만큼 차이나는 배열을 만들어서 출력하면 된다.")]),a._v(" "),r("p",[a._v("constructive 문제 답게, 개인마다 풀이 방법이 상이 하게 다를 것이다. 나는 다음과 같이 했다.")]),a._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[a._v("int maxa = (1LL << 18) - 1;\ncout << 2 << ' ' << 3 << endl;\ncout << maxa << ' ' << k << ' ' << 0 << endl;\ncout << maxa - k << ' ' << maxa << ' ' << k << endl;\t\n")])])]),r("p",[a._v("maxa-k는 항상 k보다 크다. 그렇기 때문에 bob의 알고리즘은 maxa -> maxa-k >> maxa >> k 순으로 될것이다. 하지만 maxa-k & k는 항상 0이기 때문에 최적해 보다 k가 작아진다.")]),a._v(" "),r("h2",{attrs:{id:"e"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#e"}},[a._v("#")]),a._v(" E")]),a._v(" "),r("p",[a._v("Editorial을 봤다.(http://codeforces.com/blog/entry/75432)")]),a._v(" "),r("p",[a._v("operation 1, 2로 우리는 다음과 같은 사실을 알 수 있다.")]),a._v(" "),r("ul",[r("li",[a._v("op 2를 통해 모든 상자의 level差를 최대 1로 줄일 수 있다. 즉 parity만 남는다.")]),a._v(" "),r("li",[a._v("op 1을 통해 임의의 두 포인트를 잡고 그 두 포인트의 parity를 항상 바꿀 수 있다. 비엔나 소시지를 생각해 보자.")]),a._v(" "),r("li",[a._v("n*m이 홀수면 모든 경우의 수에서 flatten 할 수 있다.")]),a._v(" "),r("li",[a._v("n*m이 짝수면 짝수 층(=홀수 층)이 개수가 짝수이여야 한다.")])]),a._v(" "),r("p",[a._v("k = R-L+1(가능한 level의 수. ex. {3, 4, 5, 6, 7}.length = 5)라 하고, 이때의 짝수의 수를 E, 홀수의 수를 O라고 하자. 어떤 수 (i, 0 <= i <= n*m)에 대하여 정확히 i개의 짝수층을 갖는 경우의 수는 다음과 같다.")]),a._v(" "),r("p",[a._v("E^i * O^(n"),r("em",[a._v("m-i) * nCr(n")]),a._v("m, i)")]),a._v(" "),r("p",[a._v("즉 답은")]),a._v(" "),r("p",[a._v("sigma(i=0 to n * m/2) E^2i ** O(n"),r("em",[a._v("m - 2i) ** nCr(n")]),a._v("m, 2i)\n이다")]),a._v(" "),r("p",[a._v("LaTex로 표시되어 있지 않아서 눈치를 못 챌수도 있지만, 이는 이항 정리의 전개식의 형태를 띤다. 이를 정리하면 다음과 같다.")]),a._v(" "),r("p",[a._v("(E+O)^(n"),r("em",[a._v("m) = sigma(i=0 to n * m/2) E^2i * O(n")]),a._v("m - 2i) * nCr(n*m, 2i) + sigma(i=1 to nm/2)[E^2i-1 * O(nm-(2n-1)) * nCr(nm, 2i-1)]")]),a._v(" "),r("p",[a._v("(E-O)^(n"),r("em",[a._v("m) = sigma(i=0 to n * m/2) E^2i * O(n")]),a._v("m - 2i) * nCr(n*m, 2i) - sigma(i=1 to nm/2)[E^2i-1 * O(nm-(2n-1)) * nCr(nm, 2i-1)]")]),a._v(" "),r("p",[a._v("즉 위 두개의 식 2개를 더하고 2로 나누면 우리가 원하는 값이 될 것이다. modular 연산에 신경쓰자. 그냥 마음편하게 modular exponent를 한 후 pow(2, mod-2) % MOD를 하자.")]),a._v(" "),r("p",[a._v("Editorial에 정말 정신나간 풀이법이 있는데, 나는 그것을 이해하는 것을 포기했다. 스터디에서 들었는데, 그런 식으로 1대1 매칭이 된다는 것을 활용해서 바로 답을 구하셨다는데... 아 ㅋㅋ")]),a._v(" "),r("h2",{attrs:{id:"f"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#f"}},[a._v("#")]),a._v(" F")]),a._v(" "),r("p",[a._v("손도 못댔다.")]),a._v(" "),r("h2",{attrs:{id:"g"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#g"}},[a._v("#")]),a._v(" G")]),a._v(" "),r("p",[a._v("허허")]),a._v(" "),r("h1",{attrs:{id:"_1355-round-643-div-2"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_1355-round-643-div-2"}},[a._v("#")]),a._v(" 1355(# Round 643 div. 2)")]),a._v(" "),r("p",[a._v("2020년 6월 8일 ~ 6월 14일")]),a._v(" "),r("hr"),a._v(" "),r("h2",{attrs:{id:"a"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#a"}},[a._v("#")]),a._v(" A")]),a._v(" "),r("p",[a._v("맨~처음 봤을때는 이게 뭐지? 싶었는데, 더해지는 수인 maxDigit(an)은 항상 한자리수 * 한자리수 이다. 따라서 연산을 계속하다보면 100의 자리수가 9에서 0으로 넘어가는 시점이 나온다. 주어지는 수 a1가 1000보다 작은 경우는 최악의 경우 10XX, a1가 1000이상인 경우는 최악의 경우 1000의 자릿수가 1커지고, 100의 자릿수가 0인 어떤 수에서 멈추게 될 것이다. 따라서 단순한 반복문 만으로 충분히 주어진 문제를 시간 안에 풀 수 있다. *애초에 그렇게 만들어진 문제다.")]),a._v(" "),r("h2",{attrs:{id:"b"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#b"}},[a._v("#")]),a._v(" B")]),a._v(" "),r("p",[a._v("정렬 후 앞쪽서 부터 만들수 있는 가장 작은 크기의 group을 만들면서 가면 된다. 이 방법이 최적이라는 증명은 하지 못했지만, 맞을 것이라는 직감으로 풀었다.")]),a._v(" "),r("h2",{attrs:{id:"c-2"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#c-2"}},[a._v("#")]),a._v(" C")]),a._v(" "),r("p",[a._v("못 풀었다. 스터디원의 풀이는 다음과 같다.\n우선 A, B, C, D 의 범위를 보아하니 O(n)이 아니면 풀지 못할거라고 생각했다.\n우선 x를 fix해놓고 y, z의 변화에 따른 가능한 해의 범위를 그래프로 나타내면 직각삼각형과 직사각형을 붙여놓은 모양이 나온다. 이 도형의 넓이를 각각의 x마다 구하면 되는데, 이때 x의 값에 따라 삼각형이 잘리거나, 없을수도 있고, 직사각형마저 짤릴 수도 있다. 이러한 조건을 잘 처리해 주기만 하면 된다.")]),a._v(" "),r("h2",{attrs:{id:"d-2"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#d-2"}},[a._v("#")]),a._v(" D")]),a._v(" "),r("p",[a._v("우선 2<=S/N 인 경우 Petya가 이긴다는 사실은 자명하다. 모든 배열의 값을 2 이상으로 설정한 뒤 K=1로 하면 K, S-K 그 둘중 어느것도 안되기 때문이다.\n문제는 1<=S/N<2 인데.... 유감스럽게도 이것 역시 B처럼 증명은 못했다. 어떤 배열과 K를 주어도 항상 K또는 S-K를 만들수 있을것이라고 생각은 했는데 증명은 못했다. 실제로 스터디에서 제일 잘하는 분도 이건 editorial을 봤다.")]),a._v(" "),r("h2",{attrs:{id:"e-2"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#e-2"}},[a._v("#")]),a._v(" E")]),a._v(" "),r("p",[a._v("당연히 못 풀고, 스터디원의 도움을 받았다.\nA+R <= M과 A+R > M으로 나누어 볼 수 있다.\ncost함수를 h에 대한 함수로 보면, 두 case모두 아래로 볼록 함수임을 증명 할 수 있고, 그 말은 즉슨 parametric search를 이용해 답을 구할 수 있다는 뜻이다.")]),a._v(" "),r("h2",{attrs:{id:"f-2"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#f-2"}},[a._v("#")]),a._v(" F")]),a._v(" "),r("p",[a._v("풀 수 있을리가 없다.")]),a._v(" "),r("h1",{attrs:{id:"_1358-round-645-div-2"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_1358-round-645-div-2"}},[a._v("#")]),a._v(" 1358(# Round 645 div. 2)")]),a._v(" "),r("p",[a._v("2020년 6월 15일 ~ 6월 21일")]),a._v(" "),r("hr"),a._v(" "),r("h2",{attrs:{id:"a-2"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#a-2"}},[a._v("#")]),a._v(" A")]),a._v(" "),r("p",[a._v("row와 column수 중 하나라도 짝수가 있는 경우와 모두 홀수 인 경우로 나눌 수 있다.\n하나라도 짝수가 있는 경우 답은 row * column / 2 임이 자명하다.\nrow와 column수 모두 홀수 인 경우는 column 하나를 분리해보면 된다. 한줄 떼고 남은 것은 전등에 의해 빈 공간 없이 채워 지고, 한 줄짜리는 칸 하나를 남기고 다 채워 진다. 남은 한 칸을 전등으로 채우면 된다.\n그냥 답은 floor(n * m + 1) / 2)다.")]),a._v(" "),r("h2",{attrs:{id:"b-2"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#b-2"}},[a._v("#")]),a._v(" B")]),a._v(" "),r("p",[a._v("일단 정렬을 하자.\n할머니가 나가는 행위는 모아서 한꺼번에 해도 상관이 없다. 즉 자신보다 필요인원이 많은 할머니가 나갈때 같이 나가도 상관이 전혀 없다.\n할머니들을 오름차순으로 정렬 후, 뒤에서 부터 탐색하면서 인덱스(자신을 제외한 나간 인원)가 배열 값(자신이 원하는 인원)보다 같거나 크면(a[i] <= i) 그 인덱스 + 1(Maria)을 출력하면 된다.")]),a._v(" "),r("h2",{attrs:{id:"c-3"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#c-3"}},[a._v("#")]),a._v(" C")]),a._v(" "),r("p",[a._v("풀이 방법이 여러가지가 있다.\n우선 나는 ㄱ 경로가 최솟값, ㄴ 경로가 최댓값이고 답이 최댓값-최솟값+1 이라는 점을 이용했다.\n이는 주어진 범위의 대각선의 길이를 모두 더하는 문제라고 볼 수 있다. 간단한 수식을 이용하여 풀었다.\n다음은 스터디에서 본 더 창의적인 방법이다.\nㄱ 경로는 최솟값이고, ㄴ 경로는 최댓값이다. ㄱ 경로가 주어졌을때, 작은 ㄱ자 경로 하나를 ㄴ자로 바꾸면 값은 정확히 1이 상승한다. 그리고 그러한 연산을 정확히 (x2-x1)(y2-y1)번 수행 할 수 있다. 따라서 답은 (x2-x1)(y2-y1) + 1 이다.")]),a._v(" "),r("p",[a._v("음, 반대로 말하면 격자에 주어진 범위에서 오른쪽으로 기울어진 대각선을 그릴때 그 대각선의 길이의 합이 (x2-x1)(y2-y1) + 1 이 된다는 뜻이네... 신기하구만")]),a._v(" "),r("h2",{attrs:{id:"d-3"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#d-3"}},[a._v("#")]),a._v(" D")]),a._v(" "),r("p",[a._v("이 역시 풀지 못했다.\n대충 최적해는 항상 월의 마지막날에서 끝남을 증명하여 O(n log n)안에 풀 수 있다고 한다.")]),a._v(" "),r("h2",{attrs:{id:"e-f"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#e-f"}},[a._v("#")]),a._v(" E, F")]),a._v(" "),r("p",[a._v("포기하겠어")]),a._v(" "),r("h1",{attrs:{id:"_1362"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_1362"}},[a._v("#")]),a._v(" 1362")]),a._v(" "),r("hr"),a._v(" "),r("p",[a._v("이번 셋은\n이번 Editorial의 품질이 영 아니라는 말이 많다. 실제로 퀄리티가 그렇게 좋진 않았다. 특히 E번 문제는 증명이 꼭 있어야 할텐데 증명이 없었다. 제시한 코드도 읽기 힘들었다. 그래서 E번은 패스했다.")]),a._v(" "),r("h1",{attrs:{id:"a-3"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#a-3"}},[a._v("#")]),a._v(" A")]),a._v(" "),r("p",[a._v('A/B 가 2^n 꼴로 나타낼 수 없으면 -1, 그렇지 안흐염 2^n을 8, 4, 2의 곱으로 그리디하게 표현하는 문제이다.\na/b가 홀수가 될때까지 2로 나누다보면 1 또는 1이 아닌 홀수가 나올것이다. 1이 아닌 홀수가 나오면 -1, 그렇지 않으면 ceil(a/b // 8)이다. ("//" : 몫 연산)')]),a._v(" "),r("h1",{attrs:{id:"b-3"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#b-3"}},[a._v("#")]),a._v(" B")]),a._v(" "),r("p",[a._v("주어지는 s는 항상 1024=2^10 보다 작으므로, 답 k도 최댓값이 1023이다.\nk의 범위가 충분이 작으므로 1부터 1023까지 brute force를 통해 계산하면 된다.\n주어진 조건을 만족하기 위해서는 정확히 n/2개의 쌍의 xor 매치가 나와야 한다. k가 답이면, x 와 x xor k모두 배열에 있어야 한다는 뜻이다. 배열의 어떤 수 x에 대해 x xor k 가 배열에 없다면 k는 조건을 만족하지 못한다는 듯이다. 배열의 값을 인덱스로 사용하는 1023 크기의 배열을 만들면 쉽다.")]),a._v(" "),r("h1",{attrs:{id:"c-4"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#c-4"}},[a._v("#")]),a._v(" C")]),a._v(" "),r("p",[a._v('2^0, 2^1, 2^2, ... 의 자리 비트가 0부터 n 몇번 변하는 지를 계산하면 된다.\n최하위 부터, n, n/2, n/4, ... 번 변하게 된다.\n따라서 n // 2("//": 몫 연산)가 0이 될때까지 답에 더해주면 된다.')]),a._v(" "),r("h1",{attrs:{id:"d-4"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#d-4"}},[a._v("#")]),a._v(" D")]),a._v(" "),r("p",[a._v("쓰고싶은 Topic의 숫자가 낮은 블로그 부터 Topic을 쓰면 된다. 이때 인접 블로그(노드)의 Topic을 조사하여 현재 쓰고자 하는 Topic의 숫자가 가능한 것인지를 검사하면 된다.")]),a._v(" "),r("p",[a._v("가령 이미 인접 블로그에 1번~n번 Topic이 있는데 n번 Topic을 작성해야 하는 상황이거나,\n(인접 블로그의 수) + 1 < (작성하고자 하는 Topic 번호) 라면 불가능하다.")]),a._v(" "),r("h1",{attrs:{id:"e-3"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#e-3"}},[a._v("#")]),a._v(" E")]),a._v(" "),r("p",[a._v("못 풀었다. Editorial은 볼 엄두가 안나더라.\n일단 모든 ki에 대하여 중복 등장한 횟수가 p보다 작을 때는 아주 쉽다. p^(ki_max) 에서 나머지 p^ki들을 빼주면 된다. 그런데 그렇지 않은 상황이 문제다. 그래서 못 풀었다. Editorial은 진짜 신묘하게 풀던데 ㅋㅋㅋ")]),a._v(" "),r("h1",{attrs:{id:"f-3"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#f-3"}},[a._v("#")]),a._v(" F")])])}),[],!1,null,null,null);t.default=_.exports}}]);