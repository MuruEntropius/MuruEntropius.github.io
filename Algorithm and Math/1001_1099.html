<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Codeforces(1001~1099) | I WANNA GO HOME</title>
    <meta name="description" content="Today I Learned">
    <meta name="generator" content="VuePress 1.3.0">
    
    
    <link rel="preload" href="/assets/css/0.styles.dfa0cb16.css" as="style"><link rel="preload" href="/assets/js/app.ce68a122.js" as="script"><link rel="preload" href="/assets/js/2.42c63668.js" as="script"><link rel="preload" href="/assets/js/5.ad43994a.js" as="script"><link rel="prefetch" href="/assets/js/10.1d8795cf.js"><link rel="prefetch" href="/assets/js/11.79b85948.js"><link rel="prefetch" href="/assets/js/12.310ed61f.js"><link rel="prefetch" href="/assets/js/13.eba0004e.js"><link rel="prefetch" href="/assets/js/14.3ba1a09b.js"><link rel="prefetch" href="/assets/js/3.dc36bf0e.js"><link rel="prefetch" href="/assets/js/4.b0dd307f.js"><link rel="prefetch" href="/assets/js/6.8f9999d9.js"><link rel="prefetch" href="/assets/js/7.76099345.js"><link rel="prefetch" href="/assets/js/8.fda68eb4.js"><link rel="prefetch" href="/assets/js/9.8388c8d6.js">
    <link rel="stylesheet" href="/assets/css/0.styles.dfa0cb16.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container no-sidebar"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">I WANNA GO HOME</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <!----></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><!---->  <!----> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="codeforces-1001-1099"><a href="#codeforces-1001-1099" class="header-anchor">#</a> Codeforces(1001~1099)</h1> <hr> <h2 id="_1155e"><a href="#_1155e" class="header-anchor">#</a> 1155E</h2> <ul><li>참조 코드: https://codeforces.com/blog/entry/66687</li> <li>관련 지식:
<ul><li>Modular Multiplicative Inverse(모듈러 역수)</li> <li>Gaussian Elimination(가우스 소거법)</li> <li>Fermat's little Theorem(FiL, 페르마의 소정리)</li></ul></li></ul> <h3 id="modular-multiplicative-inverse"><a href="#modular-multiplicative-inverse" class="header-anchor">#</a> Modular Multiplicative Inverse</h3> <p>Modular Multiplicative Inverse, 모듈러 역수란 정수 a에 곱해서 MOD P 연산을 하면 나머지가 1이 나오게 하는 수이다.
예를 들어, m이  a * m === 1 (MOD P) 일때, m은 a mod P의 모듈러 역수이다. 모듈러 역수는 a와 p가 서로소 일때만 존재하며,
항상 0과 p-1 사이의 값을 가진다.
a MOD P 의 모듈러 역수를 구하는 방법은 여러가지가 있다. m에 0부터 p-1의 값을 하나씩 넣어 보는 방법, 확장된 유클리드 호제법 등이 있다.   또는 p가 소수이고, a와 p가 서로소 일때 m === a^(p-2) (MOD p) 을 만족하므로 이를 계산 하는 방법이 있다.</p> <h3 id="fermat-s-little-theorem-fil"><a href="#fermat-s-little-theorem-fil" class="header-anchor">#</a> Fermat's little Theorem(FiL)</h3> <p>페르마의 소정리는 &quot;소수 p와, p의 배수가 아닌 a가 있을때 항상 a^(p-1) === 1 (MOD p)를 만족함&quot; 이다.</p> <h3 id="gaussian-elimination"><a href="#gaussian-elimination" class="header-anchor">#</a> Gaussian Elimination</h3> <p>가우스 소거법은 연립 일차 방정식을 푸는 해법중 하나이다.
연립 일차 방정식 Ax = B이 있을때, A와 B를 붙여놓고
* 행과 행을 바꾸기
* 행에 0이 아닌 상수를 곱하기
* 행에 상수를 곱하고 다른 행에 더하기
등의 연산을 통해서 사다리꼴행렬로 만든 후, 아래서 부터 미지수를 구해나가는 Back Substitution을 통해 미지수를 구해나간다.</p> <hr> <p>위 링크의 Editorial의 코드를 해석하고 정리했다.</p> <p>이 해답의 전략은 a_0부터 a_10를 연립일차방정식의 미지수로 두고, 가우스 소거법을 통해 해를 구하는 방법이다. 0부터 10까지의 &quot;? i&quot;쿼리에 대한 대답이 우변(위 코드에서는 mat[i][sz(f)]) 이 되는 것이다.</p> <div class="language- extra-class"><pre class="language-text"><code>    fore(j, 0, sz(mat)) {
		int nid = -1;
		fore(i, j, sz(mat)) {
			if(mat[i][j] != 0) {
				nid = i;
				break;
			}
		}
		if(nid == -1)
			continue;
		
		swap(mat[j], mat[nid]);
		fore(i, 0, sz(mat)) {
			if(i == j) continue;
			int cf = mul(mat[i][j], inv(mat[j][j]));
			
			fore(cj, j, sz(mat[i]))
				mat[i][cj] = norm(mat[i][cj] - mul(cf, mat[j][cj]));
		}
	}
</code></pre></div><p>사다리꼴 행렬을 만들기 위해 0이 아닌 수를 mat[j][j]에 놓아야 한다. mat의 j번째 열을 밑으로 훑으면서 0이 아닌 수를 찾으면 mat[j]로 swap한다.</p> <p>여기서부터가 정말 재미있어 진다. 저 반복문은 &quot;행에 상수를 곱하고 다른 행에 더하기&quot;작업을 실행하고 있다. 즉 cf는 multiplyer다. 보통의 multiplyer는 i/j겠지만, 모듈러 연산에서는 좀 다르다.</p> <p>위 cf라는 수는 cj==j 일때, mat[i][cj]를 항상 0으로 만든다. 그 이유는 무엇일까?
cf는 mat[i][j] * mat[j][j]^(p-2)이다.</p> <p>따라서 cj=j(반복문의 시작)일때 mat[i][j] = norm(mat[i][j] - (mat[i][j] * mat[j][j]^(p-1)) MOD p)이다. 이때, 페르마의 소정리에 의해 mat[j][j]^(p-1)가 1이 되므로 남은건 norm(mat[i][j] - (mat[i][j] MOD p)), 즉 0이 된다.</p> <p>연산을 계속하다 보면 이런식으로 된다.</p> <p>반복문 fore(cj, j, sz(mat[i]))가 j에서 시작하는 이유는 보기처럼 j열 앞에 있던 수는 모두 0이 되었기 때문에 cf를 곱해 봤자 0이다. 그래서 필요가 없다.</p> <div class="language- extra-class"><pre><code>vector&lt;int&gt; a(sz(f), 0);
fore(i, 0, sz(a)) {
	if(mat[i][i] == 0)
		continue;
	a[i] = mul(mat[i][sz(a)], inv(mat[i][i]));
}
</code></pre></div><p>이제 a_0부터 a_10을 구했으니, 남은건 0부터 10^6+3까지 넣어보면서 조건을 만족하는 x를 찾으면 된다.</p> <hr></div> <footer class="page-edit"><!----> <!----></footer> <!----> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.ce68a122.js" defer></script><script src="/assets/js/2.42c63668.js" defer></script><script src="/assets/js/5.ad43994a.js" defer></script>
  </body>
</html>
